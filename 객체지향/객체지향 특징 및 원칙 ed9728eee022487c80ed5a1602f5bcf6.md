# 객체지향 특징 및 원칙

# 객체지향 프로그래밍이란!!!!!

프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

# 객체 지향의 4가지 특징

### 추상화

- 객체들의 공통적인 특징을 묶어 클래스로 정의하는 것
- 추상화를 진행하면 항상 이를 대표하는 이름이 생성됨
- 메소드를 정의하는 것도 기능의 추상화라고 볼 수 있다.

### 캡술화

- 객체의 내용과 기능을 결합시켜서 하나로 묶음으로서 관리하는 것
- 이를 통해 데이터를 은닉하여 직접 객체의 데이터에 접근할 수 없지만 그 데이터에 대한 접근을 정의한 메소드는 노출되어 있어서 메소드를 통해 간접적으로 객체의 데이터에 접근할 수 있음
- 목적: 코드를 재수정없이 재활용하는 것!!

### 상속성

- 상위 클래스의 개념을 하위 클래스가 물려받는것
- 하나의 클래스가 가지는 특징들을 그대로 다른 클래스에게 물려주고 싶을때 사용

다중 상속 XX → 해결하기 위해 인터페이스를 사용

### 다형성

- 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미
- 하나의 변수명,함수명 등이 상황에 따라 다른 의미로 해석될수 있는것

오버라이딩 : 부모 클래스의 메서드와 같은 이름, 매개변수를 재정의하는것

오버로딩 : 같은 이름의 함수를 여러개 정의하고 매개변수의 타입과 개수를 다르게하여 매개변수에 따라 다르게 호출할 수 있게하는 것

- 클래스: 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수의 메서드로 정의한 것
- 인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당

# 객체 지향 설계 : SOLID

- 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것

→ 좋은 소프트웨어는 낮은 결합도 높은 응집도

→ 모듈 또는 클래스 당 하나의 책임을 주어 더욱더 독립된 모듈(클래스)을 만들기 위함

## 5대 원칙

### 1. SRP (Single Responsibility Principle) : 단일 책임 원칙

> "어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다." -로버트 C. 마틴

- 클래스를 설계할 때 어플리케이션의 경계를 정하고, 추상화를 통해 어플리케이션 경계 안에서 필요한 속성과 메서드를 선택하여 설계 해야 한다.

목적과 취지에 맞는 속성과 메서드로 구성 해야 한다. 즉 관련된 책임만 주라는 것이다. → 추상화랑 연관이 깊다.

### 2. OCP (Open Closed Principle) : 개방폐쇄 원칙

> "소프트웨어 엔티티(클래스,모듈,함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴

- 상위 클래스 또는 인터페이스를 중간에 두어 직접적인 연동은 피하게 설계!!!

![%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled.png](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled.png)

→ 메서드를 정의해서 드론들을 업데이트를 한다.!!

### 3. LSP (Liskov Substitution Principle) : 리스코프 치환 원칙

> "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C. 마틴

→ 인터페이스와 클래스 관계, 상위 클래스와 하위 클래스 관계를 얼마나 잘 논리적으로 설계 했느냐가 관건!!!

상속은 확장이다.  → 하위 클래스가 상위클래스 역할을 대신할 때 논리적을 맞아 떨어져야 된다.

ex) 아버지와 아들 // 아들은 아버지의 한종류이다? → LSP 위배

포유류와 고래 // 고래는 포유류의 한 종류이다!!  → 부합

### 4. ISP (interface Segregation Principle) : 인터페이스 분리 원칙

> "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다." - 로버트 C. 마틴

**ISP(인터페이스 분리 원칙)은 SRP(단일 책임 원칙)과 같은 원인에 대한 다른 해결책을 제시하는 것이다.**

![%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled%201.png](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled%201.png)

ISP는 해당 클래스를 그냥 냅두는 상태에서 인터페이스 최소주의 원칙에 따라 각 상황에 맞는 기능만 제공하도록 필터링 한다고 생각!!!

→ 상위 클래스는 풍성할 수록 , 인터페이스는 작을 수록 좋다!

### 5. DIP (Dependency Inversion Principle) : 의존 역전 원칙

> "고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화 된 것에 의존해야 한다."

"추상화 된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화 된 것에 의존해야 한다."

"자주 변경되는 구체(Concrete) 클래스에 의존하지 마라" - 로버트 C. 마틴

- 추상 클래스 또는 상위 클래스는 구체적인 구현 클래스 또는 하위 클래스에게 의존적이면 안된다.
- → why : 구체적인 클래스는 코딩에 있어서 가장 전면적으로 노출되고 사용되기 때문에 변화에 민감!
- 위배하면 구체화된 클래스를 변경할때마다 상위 클래스 or 추상클래스가 변화해야된다.

하위클래스나 구체클래스에게 의존하면 안된다.

![%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled%202.png](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled%202.png)

- 스노우는 겨울 폭설에 오는 경우가 아니면 쓸일이 제로임 그런데 스노우 타이어에 의존하고 있다..

![%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled%203.png](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%20ed9728eee022487c80ed5a1602f5bcf6/Untitled%203.png)

- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향 받지 않게 의존 방향을 역전!!!

상위로 갈 수록 더 추상적이고 변화에 민감하지 않고 수정 가능성이 낮아진다는 사실도 알아두면 좋다.

# 객체 지향 프로그래밍의 장,단점

## 장점

- 코드 재사용이 용이

    남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음

- 유지보수가 쉬움

    절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨.

- 대형 프로젝트에 적합

    클래스 단위로 모듈화 시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명,여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.

## 단점

- 처리속도가 상대적으로 느림
- 객체가 많으면 용량이 커질 수 있음
- 설계시 많은 시간과 노력이 필요

 

- 참고

[[Java] 객체 지향 설계란? (SOLID)](https://limkydev.tistory.com/77)