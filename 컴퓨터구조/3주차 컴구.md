# 3주차 컴구

# 리틀 엔디안, 빅엔디안

비트와 바이트 

- 컴퓨터는 모든 데이터를 2진수로 표현하고 처리한다.
- 비트 : 컴퓨터가 데이터를 처리하기 위해 사용하는 데이터의 최소 단위(0,1)만 저장
- 바이트 : 비트가 8개모여서 구성, 한 문자를 표현할 수 있는 최소 단위

## 엔디안 이란?

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻한다. (바이트를 배열하는 방법을 특히 바이트 순서라 한다.)

## 리틀 엔디안 vs 빅 엔디안

- Big-endian : 보통 큰 단위가 앞에 나옴 , **최상위 바이트(MSB)**부터 차례로 저장하는 방식
- Little-endian : 작은 단위가 앞에 나옴, **최 하위 바이트(LSB)**부터 차례로 저장
- Middle-endian : 두 경우에 속하지 않거나 둘을 모두 지원하는 것

### 예시

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled.png](./computer/Untitled.png)

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%201.png](./computer/Untitled%201.png)

빅 엔디언 과 리틀 엔디언

- 빅 엔디언 : 높은 주소 —— 낮은 주소
- 리틀 엔디언 : 낮은 주소 ——- 높은 주소

### 장단점

- 빅엔디언 :
    - 소프트웨어의 디버그를 편하게 해주는 경향,
    - 메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기가 쉽다는 장점을 가지고 있습니다.
    - 데이터의 각 바이트를 배열처럼 취급할 때에는 빅 엔디안 방식이 더 적합합니다.
    - 네트워크를 통해 데이터를 전송할 때에는 빅 엔디안 방식이 사용됩니다.
- 리틀 엔디언 :
    - 대부분의 인텔 CPU 계열에서는 이 방식으로 데이터를 저장합니다. →why??
    - 메모리에 저장된 값의 하위 바이트들만 사용할 때 별도의 계산이 필요 없다는 장점
    - 물리적으로 데이터를 조작하거나 산술 연산을 수행할 때에는 리틀 엔디안 방식이 더 효율적

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%202.png](./computer/Untitled%202.png)

[https://jhnyang.tistory.com/226](https://jhnyang.tistory.com/226)

# 비트연산

## 1의 보수

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%203.png](./computer/Untitled%203.png)

- NOT 연산만으로 표현
- +0과 -0이 따로 존재하는 문제점을 가집니다

## 2의 보수

- 1의 보수의 문제를 해결하기 위해 고안
- 컴퓨터가 음수를 저장하기 위해 사용하는 방법 중 하나
- 맨 앞의 비트는 부호 비트로 사용. 0이면 양수 1이면 음수

    ![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%204.png](./computer/Untitled%204.png)

- 비트연산자 NOT을 한다음 1을 더해주면 끝!

# 프로시저 호출 과정

## 프로시저

- 제공되는 인수에 따라서 특정한 작업을 수행하는 서브 루틴.
- 프로시저는 지정된 작업 외의 다른 것은 아무 것에도 영향을 주어서는 안된다.

## 프로시저 호출 후 실행 6단계

1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다 ($a0~$a3)
2. 프로시저에 제어를 넘긴다.
3. 프로시저가 필요로 하는 메모리 자원을 획득한다.
4. 필요한 작업을 수행한다.
5. 호출한 프로그램이 접근 할 수 있는 장소에 결과 값을 넣는다. ($v0~$v1)
6. 프로시저는 프로그램 내의 여러 곳에서 호출될 수 있으므로 원래 위치로 제어를 돌려준다. ($ra)

[https://hoooooooooooooop.tistory.com/entry/computer-architecture2-8](https://hoooooooooooooop.tistory.com/entry/computer-architecture2-8)

[https://gusdnd852.tistory.com/244](https://gusdnd852.tistory.com/244)

# 메모리 레이아웃

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%205.png](./computer/Untitled%205.png)

- c언어를 하지 않아도 이렇게 대부분 저장되니 다른 언어들도 참고
- 밑에서 부터 순서대로 적치
- 스택 : 높은 주소로 부터 낮은 주소순으로 적치

## 프로그램 코드

- 절대 바뀌지 않는 불변 영역
- 읽기는 가능해도 수정은 불가능

### text 영역

- 코드 자체가 기록되는 영역
- 선언된 함수들이 저장되는 영역

### init(const) 영역

- Read Only
- 절대 변경될 수 없는 상수 "그 자체"가 기록
- const 인자가 붙은 애들은 변수를 fixed시켜서 마치  상수처럼 사용할 수 있는 것에 불과함
- init영역에서는 그 중에서도 후자인 변수를 초기화할 때 쓰이는 값들"만" 저장됩니다.

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%206.png](./computer/Untitled%206.png)

- 초기화 시킬때 사용했던 상수들만 init영역에 저장 ⇒ 5, 3.14가 저장

### rodata영역

- read only data 영역
- init과 같이 리터럴 타입만 저장 + init영역에서 쓰이지 않았던 부분들만 모두 저장

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%207.png](./computer/Untitled%207.png)

- 초기화 구문을 제외하고 모조리 기록

## 전역, 정적 자료

static, global 변수들은 여기에다가 저장

전역변수와 정적변수들의 특징은 프로그램이 열릴 때 시작해서 프로그램이 닫힐때 까지 생존

RW(Read Write) 영역

### data영역

이미 초기화된, **이니셜라이징이 완료된 변수**들만 여기에 저장

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%208.png](./computer/Untitled%208.png)

- start_num 은 초기화되었으니 data영역에 저장된다.
- main함수를 실행하기 직전에 init영역을 확인하고 5의 주소를 확인하여서 그값을 준다.

### bass영역

Block Started by Symbol의 줄임말 

초기화 되지 않은 전역변수와 정적 변수를 저장

자신의 짝이 없기 때문에 init영역을 확인하지 않고 바로 0으로 초기화

→ 정적변수와 전역변수가 왜 바로 0으로 초기회된 이유

## 스택

자동 변수들, 지역 변수들이 저장되는 곳

자동변수나 지역변수들은 모두 런타임에 생성되었다가 소멸됩니다.

정적 바인딩이냐면 변수의 형태(자료형)이 컴파일 시간에 결정되기 때문

메모리 정적 할당

## 힙

메모리 동적 할당으로 저장된 데이터들

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%209.png](./computer/Untitled%209.png)

malloc함수를 호출하면 메모리 주소를 리턴해주지요? 그 메모리가 바로 힙입니다.

[https://m.blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=justkukaro&logNo=220681279377&categoryNo=9&proxyReferer=](https://m.blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=justkukaro&logNo=220681279377&categoryNo=9&proxyReferer=)

